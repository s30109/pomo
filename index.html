<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>APBD — HTML</title>
  <style>
    @page {
      size: A4;
      margin: 20mm;
    }
    html, body {
      height: 100%;
      background: #f5f5f5;
    }
    body {
      margin: 0;
      font-family: "Times New Roman", Times, serif;
      line-height: 1.25;
      color: #111;
    }
    .page {
      box-sizing: border-box;
      width: 210mm;
      min-height: 297mm;
      margin: 0 auto;
      background: white;
      box-shadow: 0 0 0.5rem rgba(0,0,0,0.15);
      padding: 20mm;
      font-size: 12pt;
      white-space: pre-wrap; /* preserve line breaks and spacing */
    }
    .meta {
      font-size: 11pt;
      color: #333;
      margin-bottom: 6mm;
    }
    .content {
      white-space: pre-wrap;
    }
    /* Bullet and check styles approximation */
    .content { counter-reset: q; }
    /* Because the source uses custom bullets (•, ✓), we keep them as is. */
    @media print {
      body { background: white; }
      .page { box-shadow: none; margin: 0; width: auto; min-height: auto; padding: 0; }
    }
  </style>
</head>
<body>
  <main class="page">
    <div class="meta">Przepisane z PDF do HTML (układ A4, Times New Roman, 12&nbsp;pt)</div>
    <div class="content">1. Jakie są cechy systemu Git?  
• Wydajny 
• Supportuje złożone modele rozgałęzień 

 
2. Jakie są cechy systemów kontroli wersji? 
• Wytrzymałość – rozproszony charakter oznacza, że nie ma pojedynczego 

punktu awarii. 
• Elastyczność – programiści mogą pracować niezależnie nad swoim lokalnym 

repozytorium ze wszystkimi dostępnymi funkcjami kontroli wersji, a następnie 
zsynchronizować zmiany w razie potrzeby. 

• Współpraca – DVCS obsługuje różne modele współpracy, od wysoce 
scentralizowanych do całkowicie rozproszonych, umożliwiając zespołom 
wybór na trybu pracy, który najlepiej pasuje do ich projektu.  
 
3. Jakie są różnice między systemem wersjonowania scentralizowanym i 
rozproszonym? 
• CVCS (scentralizowane) – systemy, w których wszystkie pliki 

przechowywane są w systemie centralnym, a pracownicy wchodzą w 
interakcje z tym centralnym repozytorium, żeby sprawdzać pliki, robić zmiany, 
a następnie commitować je do repozytorium.  
✓ Jedno repozytorium 
✓ Kontrola dostępu 
✓ Zależność od sieci 
✓ Łatwa widoczność 

• DVCS (rozproszone) – reprezentują model kontroli wersji, w którym każdy 
uczestnik projektu utrzymuje osobistą kopie całego repozytorium, w tym jego 
pełną historię. 
✓ Każdy użytkownik ma pełną kopię repozytorium 
✓ Udostępnianie peer-to-peer 
✓ Zwiększona redundancja 
✓ Lepsza obsługa branchowania i mergeowania  
✓ Zwiększona wydajność 
✓ Kontrola dostępu 
 
4. Czym jest "staging area" vs "working area/working tree"?  
• Przepływ pracy z Git: 

1. Modyfikujesz pliki w working tree. 
2. Wybierasz te zmiany, które chcesz, aby były częścią następnego commita. 

Są dodawane do staging area. 

3. Wykonujesz commit, który pobiera pliki znajdującie się w staging area i 
zapisuje snapshota na stałe w katalogu Git.  
 
5. Komendy: 
• git commit – zapisuje zmiany w lokanym repozytorium. 
• git status – wyświetlanie stanu working directory oraz staging area. Pokazuje 

zmiany, które zostały zainscenizowane (za pomocą git add ), zmiany, które nie 
są jeszcze zainscenizowane, a także pliki, które nie są śledzone przez Git. 

• git add – dodaje zmiany ze wszystkich plików w bieżącym katalogu (i jego 
podkatalogów) do staging area, przygotowując je do uwzględnienia w 
następnym commitcie. 

• git push – wysyła zmiany na serwer 
 
6. Czym jest gałąź ( branch ) w Git? 
• Branch - referencja do commita. Posiada dowolną nazwę 
 
7. Jakie są elementy ekosystemu .NET? 
• Common Type System (CTS) – definiuje wszystkie możliwe typy danych i 

konstrukcje programistyczne obsługiwane przez środowisko 
uruchomieniowe. Zapewnia on, że obiekty napisane w różnych językach .NET 
mogą ze sobą współdziałać. 

• Common Language Runtime (CLR) – zapewnia usługi, takie jak: zarządzanie 
pamięcią, bezpieczeństwo typów, obsługa wyjątków i inne.  

• Framework Class Library (FCL) – duża kolekcja klas wielokrotnego użytku, 
interfejsów i typów wartości, z których mogą korzystać aplikacje do typowych 
operacji, takich jak I/O, wątkowanie, kolekcje i inne.  

• Metadane i założenia – .NET używa założeń jako elementów składowych 
aplikacji, które zawierają metadane dotyczące typów zdefiniowanych w 
programie, w tym ich definicje i implementacje. Metadane zapewniają, że 
informacje o każdym typie i elemencie członkowskim są dostępne w czasie 
wykonywania. 

• Biblioteka Klas Bazowych (BCL) – część większej biblioteki FCL. BCL 
zapewnia najbardziej podstawowe klasy.  
 
8. Jakie są różnice między językiem Java i C#, w tym właściwości i 
podstawowe kolekcje?  
• (?) 
 
9. Jak wygląda proces kompilacji i uruchomienia aplikacji .NET w 
porównaniu do języka Java?  
• (?) 
 
10. W jaki sposób oceniamy i porównujemy algorytmy?  
• ‘Trójkąt’ Complexity, Memory, Maintenance 
 
11. Jakie są miary związane z jakością kodu? 
• (?) 
 
12. Czym jest kohezja i coupling? 
• Kohezja – odnosi się do tego, w jakim stopniu moduły powinny być zawarte w 

tym samym module. Innymi słowy, jest to miara tego, jak bardzo części kodu 
są powiązane ze sobą nawzajem. 

• Coupling – odnosi się do tego, jak wiele jeden moduł (np. klasa, funkcja) 
wie/zależy od innego modułu. 
 
13. Czym jest miara abstrakcji? 
• Miara abstrakcji – stosunek artefaktów abstrakcyjnych (abstrakcyjnych klas, 

interfejsów itd.) do artefaktów konkretnych.  
 
14. Czym jest pojęcie "connascence"? 
• Connascence – powiązanie. 
• Dwa komponenty są ze sobą powiązane, jeśli zmiana w jednym z nich 

wymagałaby modyfikacji drugiego, w celu utrzymania ogólnej poprawności 
systemu. 
 
15. Co oznacza skrót DRY? 
• Don't Repeat Yourself 
 
16. Co oznacza skrót YAGNI? 
• You Aren't Gonna Need It 
 
17. Co oznacza akronim SOLID? Wyjaśnij każdą z jego składowych. 
• Pięć reguł dotyczących programowania obiektowego 

1. S = Single Responsibility - zasada pojedynczej odpowiedzialności 
2. O = Open-Closed Principle- zasada otwarte-zamknięte 
3. L = Liskov Substitution Principle – zasada podstawienia Liskov 
4. I = Interface Segregation Principle – zasada segregacji interfejsów 

5. D – Dependency Inversion Principle – zasada odwrócenia zależności 
 
18. Czym jest piramida testów 
•          / Testy akceptacyjne \ 
•       /       Testy systemowe     \ 
•    /        Testy integracyjne        \ 
• /                    Unit testy                   \ 
 
19.  Czym są testy jednostkowe? 
• Automatyczne testy weryfikujące najmniejsze części systemu 

oprogramowania w izolacji. Ich celem jest zapewnienie, że każda jednostka 
działa zgodnie z założeniami. Są pisane przez programistów i często 
wykonywane w trakcie rozwoju, aby wcześnie wykrywać błędy i zapewniać 
stabilność funkcjonalności 
 
20. Czym są testy end-to-end (e2e)? 
• Testują pełną funkcjonalność systemu od początku do końca, obejmując 

wszystkie jego komponenty 
 
21. Czym są testy biało skrzynkowe? 
• Testy, w których tester ma dostęp do wewnętrznej struktury i kodu 

testowanego systemu. 
 
22. Czym są testy czarno skrzynkowe? 

• Testy, w których tester nie ma dostępu do wewnętrznej struktury systemu, 
skupiając się tylko na wejściach i wyjściach.  
 
23. Czym jest metoda AAA (Arrange-Act-Assert) pisania testów? 
• Sposób pisania testów, gdzie najpierw ustala się warunki testu (Arrange), 

następnie wykonuje akcję (Act), a na końcu sprawdza wynik (Assert).  
 
24. Jakie są praktyki związane z nazewnictwem testów?  
• MethodName_StateUnderTest_ExpectedBehavior: Ta strategia polega na 

rozpoczęciu nazwy od nazwy testowanej metody, następnie określeniu stanu 
lub warunku, w którym jest testowana, a na końcu oczekiwanego zachowania 
lub wyniku. Ułatwia to zrozumienie, co dokładnie jest testowane i w jakich 
okolicznościach. 

• MethodName_WhenStateUnderTest_ShouldExpectedBehavior: Ta 
strategia wprowadza słowo "should" do nazwy testu, co pozwala naturalnie i 

jasno określić, jakie zachowanie lub wynik jest oczekiwany pod określonymi 
warunkami. 
 
25. Czym są wyrażenia lambda? 
• Zwięzły sposób reprezentowania anonimowych metod (metody bez nazw) lub 

wyrażeń. 
 
26. Czym są delegaty? 
• Typ reprezentujący odwołania do metod z określoną listą parametrów i 

zwracanym typem 
 
27. Czym są klasy Action i Func ? 
• Action – typ delegaty, używany do reprezentowania metody, która ma typ – 

void i może przyjąć 0 lub więcej argumentów.  
• Func – typ delegaty, używany do reprezentowania metody, która zwraca 

wartość i może przyjąć 0 lub więcej parametrów.  
 
28. Jakie są cechy architektury REST? 
• Koncept – styl architektoniczny do projektowania aplikacji sieciowych, w 

którym usługi sieciowe są postrzegane jako zasoby i mogą być identyfikowane 
przed ich adresy URL. 

• Kluczowe cechy – wykorzystuje standardowe metody HTTP (GET, POST, PUT, 
DELETE), jest lekki (nie wymaga rozbudowanego przetwarzania jak SOAP) i 
bezstanowy. 

• Zastosowanie – Idealny do API webowych używanych przez aplikacje 
mobilne, webowe i inne aplikacje klienckie, które wymagają efektywnej, 
bezstanowej komunikacji. 
 
29. W jaki sposób ASP.NET przetwarza żądania HTTP?  
• Przetwarza żądania HTTP wykorzystując wzorce: 

1. Model-View-Controller (MVC) - umożliwia oddzielenie logiki biznesowej 
od prezentacji, co ułatwia zarządzanie i testowanie aplikacji, 

2. Web API - wspiera tworzenie usług RESTful dla aplikacji webowych i 
mobilnych, 

3. SignalR - obsługuje funkcjonalność w czasie rzeczywistym, umożliwiając 
serwerowi przesyłanie treści do klientów natychmiast po ich dostępności, 

4. Razor Pages - oferują prostszą składnię do łączenia kodu serwera z HTML, 
5. Entity Framework - upraszcza dostęp do danych, umożliwiając pracę z 

danymi jako silnie typowanymi obiektami.  
 
30. Jak projektować końcówki zgodne z architekturą REST?  
• Należy: 

1. Używać rzeczowników zamiast czasowników w ścieżkach końcówek.  
2. Nazwy kolekcji powinny być w liczbie mnogiej.  
3. Zagnieżdżać zasoby dla obiektów hierarchicznych.  
4. Obsługiwać błędy w sposób elegancki i zwracać standardowe kody 

błędów. 
5. Pozwalać na filtrowanie, sortowanie i paginację.  
 
31. Jakie są metody HTTP? 
• GET - żąda danych z zasobu i nie powinno powodować żadnych skutków 

ubocznych. 
• POST -  żąda od serwera utworzenia zasobu w bazie danych, zazwyczaj przy 

przesyłaniu formularza. 
• PUT - żąda od serwera zaktualizowania zasobu lub jego utworzenia, jeśli nie 

istnieje. 
• DELETE -  Żąda usunięcia zasobu z bazy danych.  
 
32. Co oznacza rutowanie? 
• Routowanie atrybutów w C# ASP.NET Core umożliwia określanie tras 

bezpośrednio w kontrolerach i akcjach za pomocą atrybutów.  
 
33. Co oznacza cecha "content negotiation" w architekturze REST?  

• Proces, w którym klient i serwer ustalają najbardziej odpowiednią formę 
reprezentacji zasobów na podstawie nagłówków http.  
 
34. Czym jest minimal API? 
• Interfejsy w ASP.NET Core zapewniają usprawnione podejście do budowania 

interfejsów API HTTP z mniejszą ilością standardowego kodu w porównaniu 
do tradycyjnych kontrolerów MVC. 
 
35. W jaki sposób przekazywać dane do serwera w architekturze REST?  
• W architekturze REST dane do serwera można przekazywać na trzy sposoby:  

1. Segment URL - używane do identyfikowania specyficznych zasobów.  
2. Ciało żądania (Request body) - używane do przesyłania danych, głównie 

z żądaniami POST i PUT do tworzenia lub aktualizacji zasobów.  
3. Ciąg zapytania (Query string) - dodawany do URL i używany do 

filtrowania danych lub przekazywania opcjonalnych parametrów.  
 
36. Jakie są inne podejścia do budowy aplikacji webowych niż REST?  
• RPC 
• CORBA 
• SOAP 
• GraphQL 
 
37. Czym są metody rozszerzeń? 
• W języku C# metoda rozszerzenia jest specjalnym rodzajem metody 

statycznej zdefiniowanej w statycznej klasie, która umożliwia "rozszerzenie" 
istniejącego typu o nowe metody bez modyfikowania kodu źródłowego 
oryginalnego typu lub korzystania z dziedziczenia  
 
38. Jak samodzielnie stworzyć metodę rozszerzeń? 
• Aby stworzyć metodę rozszerzeń, należy: 

1. Zdefiniować statyczną klasę. 
2. Utworzyć w niej statyczną metodę, której pierwszy parametr jest 

poprzedzony słowem kluczowym this, co wskazuje na typ, który ma być 
rozszerzony. 
 
39. Czym różni się podejście deklaratywne od imperatywnego pod kątem kodu? 
• Podejście deklaratywne używa atrybutów do definiowania reguł bez 

konieczności pisania kodu logicznego, np. atrybuty walidacyjne w modelach.  
• Podejście imperatywne polega na pisaniu kodu, który explicite sprawdza 

warunki. 
 
40. W jaki sposób przeprowadzić deklaratywną walidację w kodzie? 
• Deklaratywna walidacja jest przeprowadzana przez dodanie atrybutów 

walidacyjnych do właściwości modelu, np. [Required], [StringLength(100, 
MinimumLength = 3)], [Range(0.01, 10000.00)].  
 
41. Czym jest kontener IoC (Inversion of Control)? 
• Wzorzec projektowy, który odwraca tradycyjny przepływ sterowania poprzez 

delegowanie odpowiedzialności za tworzenie instancji obiektów do 
kontenera. Ułatwia to wstrzykiwanie zależności i zwiększa testowalność kodu.  
 
42. Za co odpowiadają metody AddSingleton() , AddScoped() i AddTransient() w 
kontekście IoC? Czym się różnią? 
• AddSingleton() - tworzy jedną instancję usługi na całe życie aplikacji.  
• AddScoped() - tworzy nową instancję usługi na każdy żądanie.  
• AddTransient() - tworzy nową instancję usługi za każdym razem, gdy jest ona 
żądana. 
 
43. Czym jest cykl życia zależności zarejestrowanej w kontenerze IoC? 
• Cykl życia zależności odnosi się do okresu, przez który instancja usługi jest 

przechowywana przez kontener IoC: może to być jednorazowe, per żądanie 
lub na czas życia aplikacji (Singleton) 
 
44. Czym się różni podejście architektoniczne "horizontal slice" od "vertical slice"?  
• Horizontal slice - aplikacja jest podzielona na warstwy (np. UI, logika 

biznesowa, dostęp do danych). 
• Vertical slice - aplikacja jest podzielona na funkcjonalne segmenty, gdzie 

każdy segment zawiera wszystko, co jest potrzebne do obsługi konkretnej 
funkcji, od UI po dostęp do danych. 
 
45. Czym są repozytoria i dlaczego je wykorzystujemy? 
• Repozytorium to wzorzec projektowy oddzielający logikę biznesową od logiki 

dostępu do danych, co ułatwia zarządzanie kodem i testowanie.  
 
46. Jakie są wady i zalety korzystania z SqlConnection i SqlCommand w porównaniu 
z użyciem EF (Entity Framework)? 
• Zalety: 

1. Bezpośrednia kontrola nad zapytaniami 
2. Lepsza wydajność. 

• Wady: 
1. Większa złożoność kodu. 
2. Trudniejsza obsługa transakcji i zarządzanie połączeniami.  
 
47. Jakie są dobre praktyki związane z wykorzystywaniem SqlConnection i 
SqlCommand ? 
• Używanie using do zarządzania zasobami, 
• Korzystanie z parametrów zapytań w celu zapobiegania atakom SQL Injection, 
• Unikanie twardego kodowania połączeń.  
 
48. Czym jest atak SQL Injection i jak się przed nim zabezpieczyć? 
• SQL Injection to atak polegający na wstrzyknięciu złośliwego kodu SQL do 

zapytania. 
• Zabezpieczenie polega na używaniu parametrów zapytań i procedur 

składowanych. 
 
49. W jaki sposób możemy oddzielić logikę biznesową od reszty kodu? 
• Można to osiągnąć poprzez wzorce takie jak warstwa serwisowa (Service 

Layer) i repozytoria. 
 
50. Jaka jest różnica między DAL (Data Access Layer) a BAL (Business Access Layer)?  
• DAL: Warstwa odpowiedzialna za bezpośrednią interakcję z bazą danych.  
• BAL: Warstwa zawierająca logikę biznesową, która wykorzystuje DAL do 

wykonywania operacji na danych. 
 
51. Czym jest programowanie równoległe? 
• Polega na wykonywaniu wielu zadań jednocześnie, wykorzystując 

wielordzeniowe procesory w celu poprawy wydajności.  
 
52. Czym jest programowanie asynchroniczne? 
• Pozwala na wykonywanie długotrwałych zadań bez blokowania głównego 

wątku, co utrzymuje aplikację responsywną.  
 
53. Jakie są wady i zalety programowania asynchronicznego? 
• Zalety: 

1. Zwiększa responsywność aplikacji,  
2. Pozwala na lepszą obsługę wielu żądań jednocześnie.  

• Wady: 
1. Może być trudniejsze do debugowania i zarządzania,  
2. Wymaga zmiany podejścia do pisania kodu.  
 
54. Czym jest proces? 
• Instancja programu działająca w odizolowanej przestrzeni pamięci, 

posiadająca własne zmienne i zasoby systemowe.  
 
55. Czym jest wątek? 
• Najmniejsza jednostka przetwarzania, którą zarządza system operacyjny, 

działająca wewnątrz procesu i dzieląca jego zasoby.  
 
56. Jakie są różnice, wady i zalety między procesami a wątkami? 
• Różnice: 

1. Procesy są bardziej izolowane, 
2. Wątki współdzielą pamięć procesu. 

• Wady i zalety procesów: Lepsza izolacja, ale większy narzut zasobów.  
• Wady i zalety wątków: Mniejsze zużycie zasobów, ale ryzyko problemów z 
współdzieleniem pamięci. 
 
57. Czym są operacje "CPU bound" i "IO bound"? 
• Operacje "CPU bound" to te, które głównie wykorzystują CPU do 

wykonywania obliczeń. 
• Operacje "IO bound" to te, które głównie czekają na operacje wejścia/wyjścia, 

takie jak dostęp do dysku lub sieci.  
 
58. Czym są operacje I/O? 
• Działania związane z wejściem (input) i wyjściem (output) danych, np. 

odczyt/zapis do plików, komunikacja sieciowa.  
 
59. Jak ręcznie tworzyć wątek? 
• Wątek można stworzyć ręcznie w C# za pomocą klasy Thread:  

Thread thread = new Thread(new ThreadStart(MethodName));  
 
60. Jakie są wady i zalety ręcznego zarządzania wątkami? 
• Zalety: 

1. Pełna kontrola nad wątkami. 
• Wady: 

1. Większa złożoność, trudność w zarządzaniu synchronizacją i unikaniem 
problemów takich jak warunki wyścigu.  
 
61. Dlaczego programowanie asynchroniczne jest ważne w kontekście aplikacji 
webowych 
• Poprawia skalowalność i responsywność aplikacji webowych, umożliwiając 

lepszą obsługę wielu żądań jednocześnie.  
 
62.  Czym jest Task? 
• Reprezentacja operacji, która może być wykonywana asynchronicznie i może 

zwracać wartość po zakończeniu. 
 
63. Czym jest pula wątków ( thread pool )? 
• Kolekcja pre-inicjowanych wątków, które są zarządzane i wykorzystywane do 

wykonywania zadań, minimalizując narzut związany z tworzeniem nowych 
wątków. 
 
64.  Do czego służą słowa kluczowe await i async ? 
• async oznacza, że metoda jest asynchroniczna  
• await wstrzymuje wykonanie metody do momentu zakończenia zadania 
asynchronicznego. 
 
65. Czym jest transakcja? 
• Sekwencja operacji wykonywana jako jedna jednostka logiczna. 
 
66. Jak korzystać z klas SqlConnection i SqlCommand ? 
using var con = new SqlConnection(connectionString); 
con.Open(); 
using var com = new SqlCommand("SELECT * FROM Table", con);  
using var reader = com.ExecuteReader();  
while (reader.Read()) { 
    // Przetwarzanie wyników 
} 
 
67. Czym są typy anonimowe? 
• Typy anonimowe pozwalają na wygodne kapsułkowanie zestawu właściwości 

w jeden obiekt bez konieczności jawnego definiowania typu. Używane są 
często w zapytaniach LINQ, gdzie wynik jest podzbiorem właściwości 
obiektów będących przedmiotem zapytania.  
 
68. Czym jest język LINQ? 
• Language Integrated Query to zestaw technologii wprowadzony w .NET 

Framework 3.5, który dodaje natywne możliwości zapytań do języków .NET, 
takich jak C#. Pozwala na pisanie zapytań bezpośrednio w języku C#.  
 
69. Czym jest składnia query syntax w języku LINQ? 
• Składnia query syntax w LINQ jest podobna do SQL i używa operatorów 

zapytań takich jak from, select, where, join, group i orderby, aby tworzyć 
zapytania. 
 
70. Czym jest składnia z wyrażeniami lambda w języku LINQ? 
• Składnia z wyrażeniami lambda w LINQ używa metod rozszerzeń z przestrzeni 

nazw System.Linq takich jak Where, Select, OrderBy, Join, GroupBy i może 
być łączona, aby tworzyć złożone zapytania.  
 
71. Jakie są wady i zalety korzystania z składni query syntax vs lambda syntax w 
LINQ? 
• Zalety query syntax: 

1. Bardziej zwięzła dla złożonych zapytań, 
2. Podobna do SQL, 
3. Łatwiejsza dla osób znających SQL. 

• Zalety lambda syntax: 
1. Większa elastyczność, 
2. Łatwiejsza do dynamicznego budowania zapytań 

• Wady query syntax 
1. Może być mniej intuicyjna dla prostych zapytań. 

• Wady lambda syntax: 
1. Może być mniej czytelna dla złożonych zapytań. 
 
72. Jakie są wady i zalety korzystania z SqlConnection vs ORM (Object-Relational 
Mapping) takiego jak EF? 
• Zalety SqlConnection: Bezpośrednia kontrola nad zapytaniami SQL, lepsza 

wydajność dla skomplikowanych zapytań. 
• Wady SqlConnection: Większa ilość kodu, trudniejsze zarządzanie 

transakcjami i połączeniami. 
• Zalety ORM: Automatyczne mapowanie obiektów do tabel, redukcja kodu, 

łatwiejsze zarządzanie relacjami i transakcjami.  
• Wady ORM: Może generować mniej wydajne zapytania, trudniejsze do 

optymalizacji dla zaawansowanych przypadków użycia. Czym jest podejście 
"code first" w EF? 
 
73. Czym jest podejście "code first" w EF? 
• Podejście "code first" w Entity Framework polega na tworzeniu i definiowaniu 

klas encji oraz relacji w kodzie aplikacji, z których następnie generowana jest 
schemat bazy danych przy użyciu migracji. 
 
74. Czym jest podejście "database first" w EF? 
• Podejście "database first" w Entity Framework polega na tym, że schemat 

bazy danych jest tworzony niezależnie od kodu aplikacji, a następnie EF 
generuje klasy encji i DbContext na podstawie istniejącego schematu bazy 
danych. 
 
75. Kiedy stosujemy podejście "code first" vs "database first"? 
• "Code first": Nowe projekty, szybki rozwój, iteracyjne zmiany, zespoły 

programistyczne. 
• "Database first": Istniejące bazy danych, złożone schematy, optymalizacja 

bazy danych, zarządzanie przez administratorów baz danych.  
 
76. Jakie są wady i zalety podejścia "code first" vs "database first"?  
• Zalety "code first": Zwinność, kontrola wersji, szybki rozwój.  
• Wady "code first": Mniejsza kontrola nad projektem bazy danych, wymaga 

znajomości EF migracji. 
• Zalety "database first": Pełna kontrola nad projektem bazy danych, znajomość 

tradycyjnych metod tworzenia baz danych. 
• Wady "database first": Problemy z synchronizacją kodu z bazą danych, mniej 

zwinne. 
 
77. Czym jest problem określany jako "lost update"? 
• "Lost update" występuje, gdy dwie transakcje jednocześnie odczytują tę samą 

wartość i obie ją aktualizują, ale ostatnia zapisuje swoje zmiany, nadpisując 
zmiany wprowadzone przez pierwszą transakcję.  
 
78. Czym jest problem określany jako "inconsistent reads"? 
• "Inconsistent reads" to sytuacja, gdy jedna transakcja czyta dane, które są 

jednocześnie modyfikowane przez inną transakcję, co prowadzi do 
niespójnych wyników w obrębie jednej transakcji.  
 
79. Czym jest blokowanie optymistyczne? 
• Blokowanie optymistyczne to strategia zarządzania współbieżnością, która 

pozwala na jednoczesne przetwarzanie wielu transakcji bez blokowania 
zasobów, ale sprawdza konflikty przed zatwierdzeniem transakcji.  
 
80. Jak implementować blokowanie optymistyczne? 
• Implementacja blokowania optymistycznego polega na dodaniu 

identyfikatora wersji (lub znacznika czasu) do danych, odczytaniu go podczas 
rozpoczęcia transakcji, a następnie ponownym odczytaniu i porównaniu 
przed zatwierdzeniem transakcji. Jeśli identyfikator wersji uległ zmianie, 
transakcja jest wycofywana. 
 
81. Jak działa atrybut ConcurrencyCheck? 
• Atrybut ConcurrencyCheck oznacza właściwość jako token współbieżności, 

co powoduje, że Entity Framework uwzględnia tę właściwość w klauzuli 
WHERE podczas wykonywania operacji UPDATE lub DELETE. Jeśli wartość tej 
właściwości zmieniła się od momentu odczytu danych, EF wyrzuci wyjątek 
DbUpdateConcurrencyException. 
 
82. Jak działa blokowanie pesymistyczne? 
• Blokowanie pesymistyczne polega na zablokowaniu danych natychmiast po 

ich odczytaniu, co uniemożliwia innym transakcjom modyfikację tych danych, 

dopóki blokada nie zostanie zwolniona. Blokada jest utrzymywana przez cały 
czas trwania transakcji. 
 
83. Czym jest wzorzec "Big Ball of Mud"? 
• "Big Ball of Mud" to wzorzec architektoniczny, który charakteryzuje się 

chaotyczną, nieprzemyślaną strukturą kodu, w której brakuje jasnego 
podziału na moduły. Kod jest trudny do utrzymania i rozbudowy z powodu 
silnego powiązania i braku organizacji.  
 
84. Jakie są trzy ogólne zestawy odpowiedzialności, które znajdujemy w każdej 
aplikacji? 
• Zestawy odpowiedzialności to: 

1. Domain (Business Logic) Concerns: Logika biznesowa,  
2. Infrastructure Concerns: Elementy infrastruktury, takie jak 

persystencja danych i komunikacja zewnętrzna.  
3. UI Concerns: Interfejs użytkownika lub API.  
 
85. Czym jest podejście określane jako "transactional script"? 
• "Transactional script" to wzorzec projektowy organizujący logikę biznesową w 

skrypty transakcyjne, które są prostymi procedurami wykonującymi zadania 
biznesowe bez konieczności stosowania złożonej architektury. Logika 
biznesowa jest oddzielona od innych aspektów aplikacji. 
 
86. Czym jest model domenowy 
• Model domenowy to koncepcyjna reprezentacja struktur i encji biznesowych 

w aplikacji, abstrahująca rzeczywiste podmioty i ich relacje. Służy do 
skoncentrowania logiki biznesowej w jednym miejscu, ułatwiając jej 
modyfikację i utrzymanie. 
 
87. Jakie są zalety i wady opisanych podejść? 
• Zalety podejścia "Big Ball of Mud": Szybki start, brak potrzeby planowania.  
• Wady podejścia "Big Ball of Mud": Trudności w utrzymaniu, brak 

skalowalności. 
• Zalety "transactional script": Prostota, łatwe do zrozumienia.  
• Wady "transactional script": Brak elastyczności, trudności w zarządzaniu 

złożoną logiką. 
• Zalety modelu domenowego: Skalowalność, koncentracja logiki biznesowej.  
• Wady modelu domenowego: Wysoka złożoność, duży nakład pracy na 

początkowym etapie. 
 
88. Czym jest wzorzec Unit of Work? 
• Wzorzec "Unit of Work" zarządza transakcjami w aplikacji, śledząc zmiany w 

obiektach i zapewniając, że wszystkie operacje w ramach jednej transakcji są 
zatwierdzane lub wycofywane razem, co pomaga w zarządzaniu 
współbieżnością i integralnością danych.  
 
89. Do czego służy CancellationToken? 
• CancellationToken umożliwia zarządzanie anulowaniem długotrwałych zadań 

w sposób kontrolowany i uporządkowany, pozwalając na zakończenie zadań, 
zwolnienie zasobów i poprawę responsywności aplikacji.  
 
90. Czym jest middleware? 
• Middleware w ASP.NET Core to oprogramowanie złożone w potok aplikacji, 

które obsługuje żądania i odpowiedzi. Każdy komponent w potoku może 
przetwarzać przychodzące żądania i wychodzące odpowiedzi, wykonując 
zadania takie jak uwierzytelnianie, logowanie, routing itp. 
 
91. Jak dodać własny middleware? 
• Aby dodać własny middleware, należy: 

1. Utworzyć klasę middleware z konstruktorem przyjmującym 
RequestDelegate i metodą Invoke lub InvokeAsync.  

2. Zarejestrować middleware w metodzie Configure klasy 
Startup za pomocą IApplicationBuilder.UseMiddleware<T>.  
 
92. Jaka jest różnica między uwierzytelnianiem i autoryzacją? 
• Uwierzytelnianie to proces weryfikacji tożsamości użytkownika lub systemu, 

natomiast autoryzacja to proces określania, do jakich zasobów lub działań 
uwierzytelniony użytkownik ma dostęp.  
 
93. Jak działa uwierzytelnianie w oparciu o bazę danych? 
• Uwierzytelnianie oparte na bazie danych polega na weryfikacji danych 

logowania użytkownika poprzez porównanie z danymi przechowywanymi w 
bazie danych. Zazwyczaj używa się do tego funkcji haszujących, aby 
zabezpieczyć hasła przed kradzieżą. 
 
94. Jak działa uwierzytelnianie wykorzystujące session ID? 
• W uwierzytelnianiu opartym na session ID, po zalogowaniu użytkownika, 

serwer tworzy sesję i wysyła ID sesji do klienta. Klient przesyła ID sesji w 
kolejnych żądaniach, umożliwiając serwerowi identyfikację użytkownika i 
autoryzację jego działań. 

95. Jak działa uwierzytelnianie wykorzystujące access token (JWT) i refresh token?  
• Uwierzytelnianie z użyciem access token (JWT) i refresh token polega na tym, 

że po zalogowaniu użytkownika serwer generuje krótko-żyjący JWT oraz 
refresh token. JWT jest używany do uwierzytelniania żądań, a refresh token do 
uzyskiwania nowych JWT, gdy obecny token wygaśnie. 
 
96. Do czego służą access token i refresh token? 
• Access token (JWT) służy do uwierzytelniania użytkownika i autoryzacji jego 

żądań. Refresh token jest używany do uzyskiwania nowych access token, gdy 
obecny wygaśnie, co pozwala na utrzymanie ciągłego dostępu do zasobów 
bez konieczności ponownego logowania użytkownika. 
 
97. Jakie są wady i zalety tokena JWT? 
• Zalety: 

1. Stateless: Brak potrzeby przechowywania sesji na serwerze.  
2. Interoperacyjność: Szeroko wspierany standard.  
3. Skalowalność: Idealny do systemów rozproszonych.  
4. Wydajność: Brak potrzeby odpytywania bazy danych dla 

każdego żądania. 
• Wady: 

1. Bezpieczeństwo: Dłuższe życie tokenów zwiększa ryzyko 
kradzieży. 

2. Brak centralnego zarządzania sesją: Trudności w 
unieważnianiu tokenów bez dodatkowej logiki.  
98. Czym się różni szyfrowanie od kodowania? 
• Kodowanie przekształca dane na inny format przy użyciu publicznie 

dostępnego schematu w celu ich łatwej konsumpcji przez różne systemy.  
• Szyfrowanie przekształca dane w nieczytelny format przy użyciu 

specyficznego algorytmu i klucza, aby zabezpieczyć dane przed 
nieautoryzowanym dostępem. 
 
99. Z czego składa się JWT? 
• JWT składa się z trzech części: 

1. Header: Metadane tokenu, takie jak typ tokenu (JWT) i 
używany algorytm podpisu. 

2. Payload: Zawiera twierdzenia (claims) na temat encji 
(zazwyczaj użytkownika). 

3. Signature: Służy do weryfikacji integralności tokenu i 
autentyczności danych w nim zawartych. 
 
100. Czym są obiekty DTO (Data Transfer Object)? 
• DTO (Data Transfer Object) to obiekty używane do przenoszenia danych 

między różnymi warstwami aplikacji, minimalizując ilość połączeń 
sieciowych. DTO zazwyczaj zawiera tylko dane i nie zawiera logiki biznesowej.  
 
101. Czym są aplikacje MPA (Multi-Page Application)? 
• MPA (Multi-Page Application) to tradycyjny model aplikacji webowych, w 

którym każda interakcja użytkownika prowadzi do załadowania nowej strony z 
serwera. Przykłady obejmują wiele stron z dynamicznie generowaną 
zawartością, ale wymagających pełnego odświeżenia przeglądarki. 
 
102. Czym są aplikacje SPA (Single-Page Application)? 
• SPA (Single-Page Application) to aplikacja webowa, która ładuje pojedynczy 

dokument HTML i dynamicznie aktualizuje zawartość w miarę interakcji 
użytkownika, bez konieczności przeładowywania całej strony. Przykłady to 
Gmail czy Google Maps. 
 
103. Jakie są wady, zalety i różnice między MPA i SPA? 
• MPA: 
• Zalety: Lepsze dla SEO, łatwiejsze do zaimplementowania, idealne dla stron z 

dużą ilością treści. 
• Wady: Wolniejsze interakcje użytkownika, większy narzut na serwer.  
• SPA: 
• Zalety: Lepsze doświadczenie użytkownika, szybsze interakcje po initialnym 

załadowaniu, lepsze dla aplikacji wymagających dużej interaktywności.  
• Wady: Trudniejsze do SEO, większa złożoność i potrzeba zarządzania stanem 

aplikacji. 
 
104. Czym jest różnica między klientem cienkim a grubym? 
• Klient cienki (thin client) polega głównie na serwerze do przetwarzania danych 

i logiki aplikacji, wysyłając tylko minimalny kod HTML, CSS i JavaScript do 
przeglądarki. 

• Klient gruby (thick client) przenosi większość logiki aplikacji na stronę klienta, 
wykonując więcej operacji w przeglądarce przy użyciu frameworków 
JavaScript jak React czy Angular. 
 
105. Czym jest ASP.NET MVC? 
• ASP.NET MVC (Model-View-Controller) to framework do budowy aplikacji 

webowych w architekturze MVC, umożliwiający oddzielenie logiki aplikacji, 

warstwy prezentacji i danych, co ułatwia rozwój, testowanie i utrzymanie 
aplikacji. 
 
106. Czym jest Razor? 
• Razor to silnik widoków używany w ASP.NET do generowania dynamicznego 

HTML. Umożliwia wstawianie C# w kodzie HTML przy użyciu składni @ do 
łatwego łączenia logiki aplikacji z prezentacją.  
 
107. Jak przekazać dane do widoku? 
• Dane można przekazywać do widoku w ASP.NET używając obiektów ViewBag, 

ViewData lub silnie typowanych modeli. ViewBag i ViewData są dynamiczne, 
podczas gdy silnie typowane modele zapewniają bezpieczeństwo typów i 
lepsze wsparcie dla Intellisense. 
 
108. Czym jest ViewBag? 
• ViewBag to dynamiczny obiekt, który pozwala na przekazywanie danych z 

kontrolera do widoku bez konieczności używania silnie typowanych modeli. 
Umożliwia łatwe przekazywanie małych ilości danych, ale nie oferuje kontroli 
typów podczas kompilacji. 
 
109. Czym są widoki silnie typowane? 
• Widoki silnie typowane używają modeli, które są specyficzne dla danego 

widoku, zapewniając bezpieczeństwo typów i lepsze wsparcie dla Intellisense 
w edytorach kodu. Model jest definiowany na początku widoku przy użyciu 
dyrektywy @model. 
 
110. Jak działa formularz HTML? 
• Formularz HTML umożliwia użytkownikom wprowadzanie danych i przesyłanie 

ich na serwer za pomocą żądania HTTP (zazwyczaj POST lub GET). Dane są 
następnie przetwarzane przez serwer, który może je zapisać, przetworzyć lub 
zwrócić odpowiedź do użytkownika. 
 
111. Czym się różni walidacja serwerowa od klienta? 
• Walidacja klienta jest wykonywana w przeglądarce użytkownika za pomocą 

JavaScript, zapewniając natychmiastową informację zwrotną. Walidacja 
serwerowa jest wykonywana na serwerze po przesłaniu formularza, co jest 
bardziej bezpieczne, ponieważ nie może być łatwo obejście przez 
użytkownika. 
 
112. Czym jest WebAssembly? 
• WebAssembly (Wasm) to binarny format instrukcji dla wirtualnej maszyny 
stosowej, który umożliwia uruchamianie kodu na stronach internetowych z 
wydajnością zbliżoną do natywnej. WebAssembly jest zaprojektowany jako 
przenośny cel kompilacji dla języków takich jak C, C++ i Rust, co pozwala na 
uruchamianie kodu w przeglądarkach.  
 
113. Jakie są wady i zalety WebAssembly? 
• Zalety: 
• Szybkość: Wydajność zbliżona do natywnej.  
• Przenośność: Może być uruchamiany na różnych platformach i 

przeglądarkach. 
• Bezpieczeństwo: Działa w bezpiecznym środowisku sandbox.  
• Wady: 
• Złożoność: Trudniejszy do debugowania w porównaniu do JavaScript.  
• Kompatybilność: Wymaga nowoczesnych przeglądarek i wsparcia dla 

WebAssembly. 
 
114. Czym jest Blazor? 
• Blazor to framework webowy opracowany przez Microsoft, który umożliwia 

tworzenie interaktywnych interfejsów użytkownika przy użyciu C# i .NET 
zamiast JavaScript. Blazor umożliwia uruchamianie kodu .NET w przeglądarce 
za pomocą WebAssembly, a także oferuje model serwerowy, gdzie interakcje 
są obsługiwane po stronie serwera przez SignalR.  
 
115. Jaka jest różnica między Blazor Server Side a Blazor Client Side? 
• Blazor Server Side: Logika aplikacji działa na serwerze, a zmiany w interfejsie 

użytkownika są przesyłane do przeglądarki przez SignalR. Wymaga stałego 
połączenia z serwerem. 

• Blazor Client Side (WebAssembly): Aplikacja działa w całości w przeglądarce 
za pomocą WebAssembly. Może działać offline po pobraniu wszystkich 
niezbędnych zasobów. 
 
116. Czym są testy integracyjne? 
• Testy integracyjne sprawdzają, czy różne komponenty systemu współpracują 

ze sobą zgodnie z oczekiwaniami. Obejmują interakcje między modułami, 
usługami lub warstwami aplikacji, zapewniając, że ich zintegrowane działanie 
spełnia wymagania. 
 
117. Czym są obiekty testowe? 
• Obiekty testowe to specjalnie przygotowane obiekty używane w testach 
jednostkowych i integracyjnych do symulowania rzeczywistych obiektów. 
Służą do izolowania testowanych jednostek oraz kontrolowania ich 
środowiska testowego. 
 
118. Czym jest mock? 
• Mock to rodzaj obiektu testowego, który jest używany do weryfikacji interakcji 

między systemem a jego zależnościami. Mocki mogą być zaprogramowane z 
oczekiwaniami dotyczącymi wywołań metod, parametrów i kolejności 
operacji, a następnie rejestrują informacje o tym, jak były używane. 
 
119. Czym jest spy? 
• Spy to specjalny rodzaj obiektu testowego, który rejestruje interakcje między 

systemem a sobą. W przeciwieństwie do mocków, spie nie są wstępnie 
programowane z oczekiwaniami, ale po prostu rejestrują wywołania metod i 
ich parametry do późniejszej analizy. 
 
120. Czym jest fake? 
• Fake to testowy zamiennik, który ma działające implementacje, ale są one 

uproszczone lub nieodpowiednie do produkcji. Fakes są używane do 
zastępowania skomplikowanych lub wolnych rzeczywistych komponentów, 
aby przyspieszyć testy. 
 
121. Czym jest stub? 
• Stub to rodzaj obiektu testowego, który zapewnia predefiniowane odpowiedzi 

na określone wywołania podczas testów. Stubs są używane do symulacji 
komponentów, z którymi testowany moduł wchodzi w interakcje, zapewniając 
kontrolowane i przewidywalne środowisko testowe. 
 
122. Czym jest dummy? 
• Dummy to rodzaj obiektu testowego, który jest przekazywany, ale nigdy 

faktycznie nie jest używany. Służy do wypełniania list parametrów lub 
spełniania sygnatur metod, umożliwiając uruchomienie testu bez 
implementacji rzeczywistej funkcjonalności, która nie jest istotna dla 
konkretnego testu.
</div>
  </main>
</body>
</html>
